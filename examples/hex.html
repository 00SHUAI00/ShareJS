<!DOCTYPE html> 
<html> 
	<head>
		<title>Hex</title>
		<style>
			body { text-align: center; }
			#board { margin: 2em; }
		</style>
		<script src="/socket.io/socket.io.js"></script>
		<script src="/share/share.js"></script>
	</head>
	<body>
		<button id='reset' onclick='reset()'>New game</button>
		<canvas id='board' width='640' height='480'></canvas>
    <script type="text/javascript">
			var defaultSide = 20, spacing = 5,
			selectedX = null,
			selectedY = null,
			grid = {width: 10, height: 10,
				at: function (x,y) {
					return this.values[y*this.width+x];
				}
			},
			playerTurn = 1,
			playerColors = [[200,0,0], [0,0,200]],
			colorStyle = function (color) {
				return 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
			},
			fillHex = function (ctx, x, y, color, side) {
				ctx.fillStyle = color;
				x += 0.5;
				y += 0.5;
				pathHex(ctx, x, y, color, side);
				ctx.fill();
			},
			strokeHex = function (ctx, x, y, color, side) {
				ctx.strokeStyle = color;
				x += 0.5;
				y += 0.5;
				pathHex(ctx, x, y, color, side);
				ctx.stroke();
			},
			pathHex = function (ctx, x, y, color, side) {
				if (!side) side = defaultSide;
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x+side, y);
				ctx.lineTo(x+side+side*Math.cos(Math.PI/3),
				           y+side*Math.sin(Math.PI/3));
				ctx.lineTo(x+side, y+2*side*Math.sin(Math.PI/3));
				ctx.lineTo(x, y+2*side*Math.sin(Math.PI/3));
				ctx.lineTo(x-side*Math.cos(Math.PI/3), y+side*Math.sin(Math.PI/3));
				ctx.lineTo(x, y);
			},
			hexEdgeWidth = function (side) {
				//  _
				// / \
				// \_/
				//   v ~~~~ this width

				if (!side) side = defaultSide;
				return side*Math.cos(Math.PI/3);
			},
			hexHeight = function (side) {
				// height of one hex of side length +side+
				if (!side) side = defaultSide;
				return 2*side*Math.sin(Math.PI/3);
			},
			adjacencies = function (x, y) {
				// odd and even columns have different adjacencies
				var odd = (x % 2 == 0) ? -1 : 1;
				return [[x-1,y], [x+1,y], [x, y-1], [x, y+1],
				        [x-1, y+odd], [x+1,y+odd]];
			},
			all = function (f, xs) {
				for (var i = 0; i < xs.length; i++) {
					if (!f(xs[i])) {
						return false;
					}
				}
				return true;
			},
			any = function (f, xs) {
				for (var i = 0; i < xs.length; i++) {
					if (f(xs[i])) {
						return true;
					}
				}
				return false;
			},
			okToPlace = function (gr, player, x, y) {
				if (x < 0 || x >= gr.width || y < 0 || y >= gr.height) return false;
				if (gr.at(x,y) != 0) return false;
				// a move adjacent to (x,y) would be OK
				var adjMoveOK = function (xy) {
					var x = xy[0], y = xy[1];
					if (x < 0 || x >= gr.width || y < 0 || y >= gr.width) {
						return true;
					}
					var val = gr.at(x,y);
					return val == 0 || val == player;
				}
				return (all(adjMoveOK, adjacencies(x,y)));
			},
			drawGrid = function (ctx, gr) {
				for (var y = 0; y < gr.height; y++) {
					for (var x = 0; x < gr.width; x++) {
						var hexX = hexEdgeWidth() + (defaultSide+hexEdgeWidth() +
						           spacing*Math.cos(Math.PI/6))*x;
						var hexY = (hexHeight() + spacing)*y +
											 (x % 2 == 0 ? 0 :
						            spacing*Math.sin(Math.PI/6)+ hexHeight()/2);

						var value = gr.at(x,y);
						if (value != 0) {
							var fillColor = colorStyle(playerColors[value-1]);
							fillHex(ctx, hexX, hexY, fillColor);
						}

						var strokeColor = 'rgb(0,0,0)';
						var ok1 = okToPlace(gr, 1, x, y),
						    ok2 = okToPlace(gr, 2, x, y);
						if (ok1 && !ok2) {
							strokeColor = 'rgb(250,140,140)';
						} else if (!ok1 && ok2) {
							strokeColor = 'rgb(140,140,250)';
						} else if (!ok1 && !ok2) {
							strokeColor = 'rgb(255,255,255)';
						}
						if (x == selectedX && y == selectedY) {
							strokeColor = 'rgb(0,200,0)';
						}

						strokeHex(ctx, hexX, hexY, strokeColor);
					}
				}
			},
			yForX = function (m, b, x) {
				// y = mx + b
				return m*x + b;
			},
			hexForPixel = function (x,y) {
				// take the pixel (x,y) and return the coordinates of the hex under
				// that pixel
				var xspacing = Math.cos(Math.PI/6)*spacing;
				x += xspacing;
				var cellwidth = defaultSide + hexEdgeWidth() + xspacing;
				var cellheight = hexHeight() + spacing;
				var xcell = Math.floor(x / cellwidth);
				// determine if we're in an odd column
				var odd = xcell % 2 != 0;
				if (odd) {
					y -= cellheight/2;
				}
				var ycell = Math.floor(y / cellheight);
				var xoff = x - xcell*cellwidth;
				var yoff = y - ycell*cellheight;

				var s3 = Math.sqrt(3);
				// top line
				var t_m = -s3, t_b = s3*(xspacing + hexEdgeWidth());
				// bottom line
				var b_m = s3, b_b = hexHeight()/2 - s3*xspacing;

				if ((xoff >= hexEdgeWidth() + xspacing && yoff <= hexHeight()) ||
				(xoff >= xspacing && xoff < hexEdgeWidth() + xspacing &&
				yoff >= yForX(t_m, t_b, xoff) &&
				yoff <= yForX(b_m, b_b, xoff))
				) {
					return {x:xcell, y:ycell};
				}
				if (yoff <= hexHeight()/2 && yoff <= yForX(t_m, hexHeight()/2, xoff)) {
					return {x:xcell-1, y:ycell + (odd ? 0 : -1)};
				}
				if (yoff >= hexHeight()/2 + spacing &&
				yoff >= yForX(b_m, spacing + hexHeight() / 2, xoff)) {
					return {x:xcell-1, y:ycell + (odd ? 1 : 0)};
				}
			},
			isComplete = function (gr) {
				for (var y = 0; y < gr.height; y++) {
					for (var x = 0; x < gr.width; x++) {
						var ok1 = okToPlace(gr, 1, x, y),
						    ok2 = okToPlace(gr, 2, x, y);
						if (ok1 && ok2) {
							// either player can place; board not complete.
							return false;
						} else if (ok1 && !ok2) {
							// player 1 can place. if player 2 can place at any point
							// adjacent to this one, the board is not complete.
							if (any(function (xy) { return okToPlace(gr, 2, xy[0], xy[1]); },
							        adjacencies(x,y))) {
								return false;
							}
						} else if (!ok1 && ok2) {
							// player 2 can place. if player 1 can place at any point
							// adjacent to this one, the board is not complete.
							if (any(function (xy) { return okToPlace(gr, 1, xy[0], xy[1]); },
							        adjacencies(x,y))) {
								return false;
							}
						} else if (!ok1 && !ok2) {
							// no-man's land
						}
					}
				}
				return true;
			},
			controller = function (gr, x, y) {
				var ok1 = okToPlace(gr, 1, x, y) || gr.at(x,y) == 1,
						ok2 = okToPlace(gr, 2, x, y) || gr.at(x,y) == 2;
				if (ok1 && !ok2) return 1;
				if (ok2 && !ok1) return 2;
				return 0;
			},
			territory = function (gr, player) {
				var num = 0;
				for (var y = 0; y < gr.height; y++) {
					for (var x = 0; x < gr.width; x++) {
						if (controller(gr, x, y) == player) {
							num++;
						}
					}
				}
				return num;
			},
			boardMouseMoved = function (e) {
				var board = document.getElementById('board');
				var x = e.clientX - board.offsetLeft, y = e.clientY - board.offsetTop;
				var hex = hexForPixel(x,y);
				if (hex) {
					selectedX = hex.x;
					selectedY = hex.y;
				} else {
					selectedX = null;
					selectedY = null;
				}
				redraw();
			},
			boardMouseClicked = function (e) {
				var board = document.getElementById('board');
				var x = e.clientX - board.offsetLeft, y = e.clientY - board.offsetTop;
				var hex = hexForPixel(x,y);
				if (hex && hex.x >= 0 && hex.x < grid.width &&
				    hex.y >= 0 && hex.y < grid.height &&
				    okToPlace(grid, playerTurn, hex.x, hex.y)) {
					//grid.values[hex.y*grid.width+hex.x] = playerTurn;
					$state.submitOp({
						p:['grid','values',hex.y*grid.width+hex.x],
						ld:0,li:playerTurn
					})
					$state.submitOp({
						p:['playerTurn'],
						od:playerTurn,
						oi:playerTurn == 1 ? 2 : 1
					});
				}
			},
			redraw = function () {
				var board = document.getElementById('board');
				var ctx = board.getContext('2d');
				ctx.clearRect(0,0,board.width, board.height);
				drawGrid(ctx, grid);

				ctx.font = '30px sans-serif';
				ctx.textBaseline = 'top';
				ctx.fillStyle = colorStyle(playerColors[playerTurn-1]);
				ctx.fillText('Player ' + playerTurn, 400,100);

				ctx.font = '20px sans-serif';
				ctx.fillStyle = colorStyle(playerColors[0]);
				ctx.fillText('P1: ' + territory(grid, 1), 400,140);

				ctx.fillStyle = colorStyle(playerColors[1]);
				ctx.fillText('P2: ' + territory(grid, 2), 400,165);

				if (isComplete(grid)) {
					ctx.fillStyle = '#000';
					ctx.fillText('Board complete!', 400,200);
				}
			},
			clear = function () {
				grid.values = [];
				for (var y = 0; y < grid.height; y++) {
					for (var x = 0; x < grid.width; x++) {
						grid.values[y*grid.width+x] = 0;
					}
				}
			},
			reset = function () {
				clear();
				playerTurn = 1;
				$state.submitOp({p:['grid','values'],od:$state.snapshot.grid.values,oi:grid.values});
				$state.submitOp({p:['playerTurn'],od:$state.snapshot.playerTurn,oi:playerTurn})
			},
			begin = function () {
				var board = document.getElementById('board');
				board.onmousemove = boardMouseMoved;
				board.onclick = boardMouseClicked;
				redraw();
			};

			function stateUpdated(op) {
				console.log("change:",op)
				for (k in $state.snapshot.grid) {
					grid[k] = $state.snapshot.grid[k]
				}
				playerTurn = $state.snapshot.playerTurn;
				redraw();
			}

			var $state;

			sharejs.open('hex', 'json', function (doc, error) {
				$state = doc;
				if (doc.created) {
					clear()
					doc.submitOp([{p:[],od:null,oi:{grid:grid,playerTurn:1}}])
				} else {
					stateUpdated()
				}
				doc.on('change', function (op) {
					stateUpdated(op)
				})
				begin()
			})
		</script>
	</body>
</html>
