// Generated by CoffeeScript 1.6.1
(function() {
  var BCSocket, Connection, Doc, MicroEvent, SockJS, WebSocket, applyChange, exports, hasBCSocket, nextTick, socketImpl, types,
    __slice = [].slice;

  window.sharejs = exports = {
    version: '0.7.0'
  };

  if (typeof WEB === 'undefined') {
    window.WEB = true;
  }

  nextTick = typeof WEB !== "undefined" && WEB !== null ? function(fn) {
    return setTimeout(fn, 0);
  } : process['nextTick'];

  MicroEvent = (function() {

    function MicroEvent() {}

    MicroEvent.prototype.on = function(event, fn) {
      var _base;
      this._events || (this._events = {});
      (_base = this._events)[event] || (_base[event] = []);
      this._events[event].push(fn);
      return this;
    };

    MicroEvent.prototype.removeListener = function(event, fn) {
      var i, listeners, _base,
        _this = this;
      this._events || (this._events = {});
      listeners = ((_base = this._events)[event] || (_base[event] = []));
      i = 0;
      while (i < listeners.length) {
        if (listeners[i] === fn) {
          listeners[i] = void 0;
        }
        i++;
      }
      nextTick(function() {
        var x;
        return _this._events[event] = (function() {
          var _i, _len, _ref, _results;
          _ref = this._events[event];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            if (x) {
              _results.push(x);
            }
          }
          return _results;
        }).call(_this);
      });
      return this;
    };

    MicroEvent.prototype.emit = function() {
      var args, event, fn, _i, _len, _ref, _ref1;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!((_ref = this._events) != null ? _ref[event] : void 0)) {
        if (event === 'error') {
          if (typeof console !== "undefined" && console !== null) {
            console.error.apply(console, args);
          }
        }
        return this;
      }
      _ref1 = this._events[event];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        fn = _ref1[_i];
        if (fn) {
          fn.apply(this, args);
        }
      }
      return this;
    };

    MicroEvent.prototype.once = function(event, fn) {
      var listener,
        _this = this;
      return this.on(event, listener = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.removeListener(event, listener);
        return fn.apply(_this, args);
      });
    };

    return MicroEvent;

  })();

  MicroEvent.mixin = function(obj) {
    var proto;
    proto = obj.prototype || obj;
    proto.on = MicroEvent.prototype.on;
    proto.removeListener = MicroEvent.prototype.removeListener;
    proto.emit = MicroEvent.prototype.emit;
    proto.once = MicroEvent.prototype.once;
    return obj;
  };

  if (typeof WEB === "undefined" || WEB === null) {
    module.exports = MicroEvent;
  }

  if (typeof WEB === "undefined" || WEB === null) {
    types = require('ot-types');
  }

  if (typeof WEB !== "undefined" && WEB !== null) {
    exports.extendDoc = function(name, fn) {
      return Doc.prototype[name] = fn;
    };
  }

  Doc = (function() {
    var setNoOp;

    function Doc(connection, collection, name, data) {
      this.connection = connection;
      this.collection = collection;
      this.name = name;
      this.subscribed = false;
      this.subscribeRequested = false;
      this.inflightData = null;
      this.pendingData = [];
      if (typeof (data != null ? data.v : void 0) === 'number') {
        this._injestData(data);
      }
    }

    Doc.prototype._send = function(message) {
      message.c = this.collection;
      message.doc = this.name;
      return this.connection.send(message);
    };

    Doc.prototype.subscribe = function(callback) {
      var msg,
        _this = this;
      if (this.subscribeRequested) {
        return;
      }
      this.subscribeRequested = true;
      if (callback) {
        this._subscribeCallback = function(error) {
          _this._subscribeCallback = null;
          return callback(error);
        };
      }
      if (this.connection.state === 'disconnected') {
        return;
      }
      msg = {
        a: 'sub'
      };
      if (typeof this.version === 'number') {
        msg.v = this.version;
      }
      return this._send(msg);
    };

    Doc.prototype.unsubscribe = function(callback) {
      var _this = this;
      if (!this.subscribeRequested) {
        return;
      }
      this.subscribeRequested = false;
      if (this.connection.state === 'disconnected') {
        return;
      }
      if (callback) {
        this._unsubscribeCallback = function(error) {
          _this._unsubscribeCallback = null;
          return callback(error);
        };
      }
      return this._send({
        a: 'unsub'
      });
    };

    Doc.prototype.fetch = function(callback) {
      if (callback) {
        this.once('fetched', callback);
      }
      return this._send({
        a: 'fetch'
      });
    };

    Doc.prototype._connectionStateChanged = function(state, data) {
      switch (state) {
        case 'disconnected':
          this.subscribed = false;
          break;
        case 'connecting':
          if (this.subscribeRequested) {
            this.subscribeRequested = false;
            this.subscribe();
          }
          if (this.inflightData) {
            this._sendOpData(this.inflightData);
          }
      }
      return this.emit(state, data);
    };

    Doc.prototype._setType = function(type) {
      var k, v, _ref, _ref1;
      if (typeof type === 'string') {
        if (!types[type]) {
          throw new Error("Missing type " + type);
        }
        type = types[type];
      }
      if (type && !type.compose) {
        throw new Error('Support for types without compose() is not implemented');
      }
      if ((_ref = this.type) != null ? _ref.api : void 0) {
        if (this._onOp) {
          this.removeListener('op', this._onOp);
        }
        for (k in this.type.api) {
          delete this[k];
        }
      }
      this.type = type;
      if (!this.type) {
        this.snapshot = null;
      }
      if (type != null ? type.api : void 0) {
        _ref1 = type.api;
        for (k in _ref1) {
          v = _ref1[k];
          this[k] = v;
        }
        if (this._onOp) {
          return this.on('op', this._onOp);
        }
      } else {
        return this.provides = {};
      }
    };

    Doc.prototype._injestData = function(data) {
      if (data == null) {
        data = {};
      }
      if (data.snapshot === void 0) {
        throw new Error('Missing snapshot');
      }
      if (data.type === void 0) {
        throw new Error('Missing type');
      }
      if (typeof this.version === 'number') {
        if (typeof console !== "undefined" && console !== null) {
          console.warn('Ignoring extra attempt to injest data');
        }
        return;
      }
      this.version = data.v;
      this.snapshot = data.snapshot;
      return this._setType(data.type);
    };

    setNoOp = function(data) {
      delete data.op;
      delete data.create;
      return delete data.del;
    };

    Doc.prototype._xf = function(client, server) {
      var _ref;
      if (server.create || server.del) {
        return setNoOp(client);
      }
      if (client.del) {
        return setNoOp(server);
      }
      if (client.create) {
        throw new Error('Invalid state. This is a bug. Please file an issue on github');
      }
      if (!(server.op && client.op)) {
        return;
      }
      if (client.type.transformX) {
        return _ref = client.type.transformX(client.op, server.op), client.op = _ref[0], server.op = _ref[1], _ref;
      } else {
        client.op = this.type.transform(client.op, server.op, 'left');
        return server.op = this.type.transform(server.op, client.op, 'right');
      }
    };

    Doc.prototype._otApply = function(opData, isLocal) {
      var create, op,
        _this = this;
      this.locked = true;
      if ((create = opData.create)) {
        this._setType(create.type);
        this.snapshot = this.type.create(create.data);
        setTimeout((function() {
          return _this.emit('ready', isLocal);
        }), 0);
        return setTimeout((function() {
          return _this.emit('created', isLocal);
        }), 0);
      } else if (opData.del) {
        this._setType(null);
        return setTimeout((function() {
          return _this.emit('deleted', isLocal);
        }), 0);
      } else if ((op = opData.op)) {
        if (!this.type) {
          throw new Error('Document does not exist');
        }
        op = opData.op;
        this.emit('before op', op, isLocal);
        if (this.incremental && this.type.incrementalApply) {
          return this.type.incrementalApply(this.snapshot, op, function(o, snapshot) {
            _this.snapshot = snapshot;
            return _this.emit('op', o, isLocal);
          });
        } else {
          this.snapshot = this.type.apply(this.snapshot, op);
          return this.emit('op', op, isLocal);
        }
      } else {
        return typeof console !== "undefined" && console !== null ? console.warn('Ignoring received no-op.', opData) : void 0;
      }
    };

    Doc.prototype._afterOtApply = function(opData, isLocal) {
      this.locked = false;
      if (opData.op) {
        return this.emit('after op', opData.op, isLocal);
      }
    };

    Doc.prototype._tryRollback = function(opData) {
      var p, undo, _i, _len, _ref;
      if (opData.create) {
        return this._setType(null);
      } else if (opData.op && opData.type.invert) {
        undo = opData.type.invert(opData.op);
        _ref = this.pendingData;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          this._xf(p, undo);
        }
        this._otApply(undo, false);
        return this._afterOtApply(undo, false);
      } else {
        this.emit('error', "Op apply failed and the operation could not be reverted");
        this._setType(null);
        this.v = null;
        return this.fetch();
      }
    };

    Doc.prototype._opAcknowledged = function(msg) {
      var acknowledgedData, callback, error, _i, _len, _ref;
      if (error === 'Op already submitted') {
        return;
      }
      acknowledgedData = this.inflightData;
      this.inflightData = null;
      error = msg.error;
      if (error) {
        this._tryRollback(acknowledgedData);
      } else {
        if (msg.v !== this.version) {
          throw new Error('Invalid version from server. Please file an issue, this is a bug.');
        }
        this.version++;
        this.emit('acknowledge', acknowledgedData);
      }
      _ref = acknowledgedData.callbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback(error);
      }
      return this.flush();
    };

    Doc.prototype._onMessage = function(msg) {
      var opData, path, pending, value, _i, _len, _ref, _ref1;
      if (!(msg.c === this.collection && msg.doc === this.name)) {
        throw new Error("Got message for wrong document. Expected '" + this.collection + "'.'" + this.name + "' but got '" + msg.c + "'.'" + msg.doc + "'");
      }
      switch (msg.a) {
        case 'data':
          this._injestData(msg);
          if (this.type) {
            this.emit('ready');
          }
          return this.emit('fetched');
        case 'sub':
          if (msg.error) {
            if (typeof console !== "undefined" && console !== null) {
              console.error("Could not open document: " + msg.error);
            }
            this.emit('error', msg.error);
            this.subscribed = false;
            this.subscribeRequested = false;
            if (typeof this._subscribeCallback === "function") {
              this._subscribeCallback(msg.error);
            }
            break;
          }
          this.subscribed = true;
          this.emit('subscribed');
          if (typeof this._subscribeCallback === "function") {
            this._subscribeCallback();
          }
          return this.flush();
        case 'unsub':
          this.subscribed = false;
          this.emit('unsubscribed');
          return typeof this._unsubscribeCallback === "function" ? this._unsubscribeCallback() : void 0;
        case 'ack':
          if (msg.error) {
            return this._opAcknowledged(msg);
          }
          break;
        case 'op':
          if (this.inflightData && msg.src === this.inflightData.src && msg.seq === this.inflightData.seq) {
            this._opAcknowledged(msg);
            break;
          }
          if (msg.v !== this.version) {
            return this.emit('error', "Expected version " + this.version + " but got " + msg.v);
          }
          opData = msg;
          if (this.inflightData) {
            this._xf(this.inflightData, opData);
          }
          _ref = this.pendingData;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pending = _ref[_i];
            this._xf(pending, opData);
          }
          this.version++;
          this._otApply(opData, false);
          return this._afterOtApply(opData, false);
        case 'meta':
          _ref1 = msg.meta, path = _ref1.path, value = _ref1.value;
          return typeof console !== "undefined" && console !== null ? console.warn('Unhandled meta op:', msg) : void 0;
        default:
          return typeof console !== "undefined" && console !== null ? console.warn('Unhandled document message:', msg) : void 0;
      }
    };

    Doc.prototype._submitOpData = function(opData, callback) {
      var entry, error,
        _this = this;
      error = function(err) {
        if (callback) {
          return callback(err);
        } else {
          return typeof console !== "undefined" && console !== null ? console.warn('Failed attempt to submitOp:', err) : void 0;
        }
      };
      if (!this.subscribeRequested) {
        return error('You cannot currently submit operations to an unsubscribed document');
      }
      if (this.locked) {
        return error("Cannot call submitOp from inside an 'op' event handler");
      }
      if (opData.op) {
        if (!this.type) {
          error('Document has not been created');
        }
        if (this.type.normalize != null) {
          opData.op = this.type.normalize(opData.op);
        }
      }
      this._otApply(opData, true);
      if (opData.op && this.pendingData.length && (entry = this.pendingData[this.pendingData.length - 1]).op) {
        entry.op = this.type.compose(entry.op, opData.op);
      } else {
        entry = opData;
        opData.type = this.type;
        opData.callbacks = [];
        this.pendingData.push(opData);
      }
      if (callback) {
        entry.callbacks.push(callback);
      }
      this._afterOtApply(opData, true);
      return setTimeout((function() {
        return _this.flush();
      }), 0);
    };

    Doc.prototype.submitOp = function(op, callback) {
      return this._submitOpData({
        op: op
      }, callback);
    };

    Doc.prototype.create = function(type, data, callback) {
      var _ref;
      if (typeof data === 'function') {
        _ref = [void 0, data], data = _ref[0], callback = _ref[1];
      }
      if (this.type) {
        return typeof callback === "function" ? callback('Document already exists') : void 0;
      }
      return this._submitOpData({
        create: {
          type: type,
          data: data
        }
      }, callback);
    };

    Doc.prototype.del = function(callback) {
      if (!this.type) {
        return typeof callback === "function" ? callback('Document does not exist') : void 0;
      }
      return this._submitOpData({
        del: true
      }, callback);
    };

    Doc.prototype._sendOpData = function(d) {
      var msg;
      msg = {
        a: 'op',
        v: this.version
      };
      if (d.src) {
        msg.src = d.src;
        msg.seq = d.seq;
      }
      if (d.op) {
        msg.op = d.op;
      }
      if (d.create) {
        msg.create = d.create;
      }
      if (d.del) {
        msg.del = d.del;
      }
      this._send(msg);
      if (!d.src) {
        d.src = this.connection.id;
        return d.seq = this.connection.seq++;
      }
    };

    Doc.prototype.flush = function() {
      var _ref;
      if (!(((_ref = this.connection.state) === 'connecting' || _ref === 'connected') && this.inflightData === null && this.pendingData.length)) {
        return;
      }
      this.inflightData = this.pendingData.shift();
      return this._sendOpData(this.inflightData);
    };

    Doc.prototype.getSnapshot = function() {
      return this.snapshot;
    };

    return Doc;

  })();

  if (typeof WEB === "undefined" || WEB === null) {
    MicroEvent = require('./microevent');
  }

  MicroEvent.mixin(Doc);

  exports.Doc = Doc;

  if (typeof WEB !== "undefined" && WEB !== null) {
    types = ottypes;
    BCSocket = window.BCSocket, SockJS = window.SockJS, WebSocket = window.WebSocket;
    if (BCSocket) {
      socketImpl = 'channel';
    } else {
      if (SockJS) {
        socketImpl = 'sockjs';
      } else {
        socketImpl = 'websocket';
      }
    }
  } else {
    types = require('ot-types');
    BCSocket = require('browserchannel').BCSocket;
    Doc = require('./doc').Doc;
    WebSocket = require('ws');
    socketImpl = null;
  }

  Connection = (function() {

    Connection.prototype._error = function(e) {
      this.setState('stopped', e);
      return this.disconnect(e);
    };

    function Connection(socket) {
      var _this = this;
      this.socket = socket;
      this.collections = {};
      this.state = 'disconnected';
      this.socket.onmessage = function(msg) {
        var collection, doc, docName;
        console.log('RECV', msg);
        if (msg.id) {
          if (msg.protocol !== 0) {
            throw new Error('Invalid protocol version');
          }
          if (typeof msg.id !== 'string') {
            throw new Error('Invalid client id');
          }
          _this.id = msg.id;
          _this.setState('connected');
          return;
        }
        if (msg.doc !== void 0) {
          collection = _this.lastReceivedCollection = msg.c;
          docName = _this.lastReceivedDoc = msg.doc;
        } else {
          collection = msg.c = _this.lastReceivedCollection;
          docName = msg.doc = _this.lastReceivedDoc;
        }
        if ((doc = _this.get(collection, docName))) {
          return doc._onMessage(msg);
        } else {
          return typeof console !== "undefined" && console !== null ? console.error('Unhandled message', msg) : void 0;
        }
      };
      this.connected = false;
      this.socket.onclose = function(reason) {
        _this.setState('disconnected', reason);
        if (reason === 'Closed' || reason === 'Stopped by server') {
          return _this.setState('stopped', _this.lastError || reason);
        }
      };
      this.socket.onerror = function(e) {
        return _this.emit('error', e);
      };
      this.socket.onopen = function() {
        return _this.setState('connecting');
      };
      this.reset();
    }

    Connection.prototype.reset = function() {
      this.id = this.lastError = this.lastReceivedDoc = this.lastSentDoc = null;
      return this.seq = 1;
    };

    Connection.prototype.setState = function(newState, data) {
      var c, collection, doc, docName, _ref, _results;
      if (this.state === newState) {
        return;
      }
      if ((newState === 'connecting' && this.state !== 'disconnected') || (newState === 'connected' && this.state !== 'connecting')) {
        throw new Error("Cannot transition directly from " + this.state + " to " + newState);
      }
      this.state = newState;
      if (newState === 'disconnected') {
        this.reset();
      }
      this.emit(newState, data);
      _ref = this.collections;
      _results = [];
      for (c in _ref) {
        collection = _ref[c];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (docName in collection) {
            doc = collection[docName];
            _results1.push(doc._connectionStateChanged(newState, data));
          }
          return _results1;
        })());
      }
      return _results;
    };

    Connection.prototype.send = function(data) {
      var collection, docName;
      console.log("SEND:", data);
      if (data.doc) {
        docName = data.doc;
        collection = data.c;
        if (collection === this.lastSentCollection && docName === this.lastSentDoc) {
          delete data.c;
          delete data.doc;
        } else {
          this.lastSentCollection = collection;
          this.lastSentDoc = docName;
        }
      }
      return this.socket.send(data);
    };

    Connection.prototype.disconnect = function() {
      return this.socket.close();
    };

    Connection.prototype.get = function(collection, name) {
      var _ref;
      return (_ref = this.collections[collection]) != null ? _ref[name] : void 0;
    };

    Connection.prototype.getOrCreate = function(collection, name, data) {
      var doc, _base;
      doc = this.get(collection, name);
      if (doc) {
        return doc;
      }
      doc = new Doc(this, collection, name, data);
      collection = ((_base = this.collections)[collection] || (_base[collection] = {}));
      return collection[name] = doc;
    };

    return Connection;

  })();

  /* 
    open: (collection, docName, options, callback) ->
      doc = @openSync collection, name
      doc.on 'ready', ->
        if doc.type and options.type
          doc.create type, -> callback()
        else
          callback()
  
    openSync: (collection, docName, options = {}) ->
      # options can have:
      # - type:'text'
      # - snapshot:{...}
      # - v:  (if you have a snapshot you also need a version and a type).
      #
      # - subscribe:true / false. Default true.
  
      
      options.type = types[options.type] if typeof options.type is 'string'
  
      if typeof options.v is 'number'
        throw new Error 'Missing snapshot' if options.snapshot is undefined
        throw new Error 'Missing type' if options.type is undefined
      else
        delete options.snapshot
  
      doc = @_get collection, docName
      if doc
        if options.subscribe isnt false
          doc.subscribe()
  
        return doc
  
      else
        return @makeDoc collection, docName, options
  
  
  
  
    makeDoc: (collection, docName, data, callback) ->
      throw new Error("Doc #{docName} already open") if @_get collection, docName
      doc = new Doc(this, collection, docName, data)
      c = (@collections[collection] ||= {})
      c[docName] = doc
  
      #doc.open (error) =>
      #  if error
      #    delete c[name]
      #  else
      #    doc.on 'closed', => delete c[name]
  
      #  callback error, (doc unless error)
  
    # Open a document that already exists
    # callback(error, doc)
    openExisting: (collection, docName, callback) ->
      return callback 'connection closed' if @state is 'stopped'
      doc = @_get collection, docName
      return @_ensureOpenState(doc, callback) if doc
      doc = @makeDoc collection, docName, {}, callback
  
    # Open a document. It will be created if it doesn't already exist.
    # Callback is passed a document or an error
    # type is either a type name (eg 'text' or 'simple') or the actual type object.
    # Types must be supported by the server.
    # callback(error, doc)
    open: (collection, docName, type, callback) ->
      return callback 'connection closed' if @state is 'stopped'
  
      # Wait for the connection to open
      if @state is 'connecting'
        @on 'connected', -> @open(collection, docName, type, callback)
        return
  
      if typeof type is 'function'
        callback = type
        type = 'text'
  
      callback ||= ->
  
      type = types[type] if typeof type is 'string'
  
      throw new Error "OT code for document type missing" unless type
  
      throw new Error 'Server-generated random doc names are not currently supported' unless docName?
  
      if (doc = @_get collection, docName)
        if doc.type is type
          @_ensureOpenState(doc, callback)
        else
          callback 'Type mismatch', doc
        return
  
      @makeDoc collection, docName, {create:true, type:type.name}, callback
  
    # Call the callback after the document object is open
    _ensureOpenState: (doc, callback) ->
      switch doc.state
        when 'open' then callback null, doc
        when 'opening' then @on 'open', -> callback null, doc
        when 'closed' then doc.open (error) -> callback error, (doc unless error)
      return
  */


  if (typeof WEB === "undefined" || WEB === null) {
    MicroEvent = require('./microevent');
  }

  MicroEvent.mixin(Connection);

  exports.Connection = Connection;

  if (typeof WEB !== "undefined" && WEB !== null) {
    hasBCSocket = window.BCSocket !== void 0;
  } else {
    Connection = require('./connection').Connection;
  }

  exports.open = (function() {
    var connections, getConnection, maybeClose;
    connections = {};
    getConnection = function(origin, authentication) {
      var c, del, location;
      if ((typeof WEB !== "undefined" && WEB !== null) && (origin == null)) {
        location = window.location;
        origin = "" + location.protocol + "//" + location.host + "/channel";
      }
      if (!connections[origin]) {
        c = new Connection(new BCSocket(origin, {
          reconnect: true
        }), authentication);
        del = function() {
          return delete connections[origin];
        };
        c.on('disconnected', del);
        c.on('connect failed', del);
        connections[origin] = c;
      }
      return connections[origin];
    };
    maybeClose = function(c) {
      var doc, name, numDocs, _ref;
      numDocs = 0;
      _ref = c.docs;
      for (name in _ref) {
        doc = _ref[name];
        if (doc.state !== 'closed' || doc.autoOpen) {
          numDocs++;
        }
      }
      if (numDocs === 0) {
        return c.disconnect();
      }
    };
    return function(collection, docName, type, options, callback) {
      var authentication, c, origin;
      if (!hasBCSocket) {
        throw new Error('Cannot find browserchannel. If you want to use a custom channel, create a connection manually.');
      }
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (typeof options === 'string') {
        options = {
          origin: options
        };
      }
      origin = options.origin;
      authentication = options.authentication;
      c = getConnection(origin, authentication);
      c.open(collection, docName, type, function(error, doc) {
        if (error) {
          callback(error);
          return maybeClose(c);
        } else {
          doc.on('closed', function() {
            return maybeClose(c);
          });
          return callback(null, doc);
        }
      });
      c.on('connect failed');
      return c;
    };
  })();

  if (typeof WEB === "undefined" || WEB === null) {
    exports.Doc = require('./doc').Doc;
    exports.Connection = require('./connection').Connection;
  }

  applyChange = function(doc, oldval, newval) {
    var commonEnd, commonStart;
    if (oldval === newval) {
      return;
    }
    commonStart = 0;
    while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
      commonStart++;
    }
    commonEnd = 0;
    while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) && commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
      commonEnd++;
    }
    if (oldval.length !== commonStart + commonEnd) {
      doc.remove(commonStart, oldval.length - commonStart - commonEnd);
    }
    if (newval.length !== commonStart + commonEnd) {
      return doc.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
    }
  };

  window.sharejs.extendDoc('attach_textarea', function(elem) {
    var attach, detach, doc, genOp, insert_listener, remove_listener, replaceText;
    doc = this;
    replaceText = function(newText, transformCursor) {
      var newSelection, scrollTop;
      newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
      scrollTop = elem.scrollTop;
      elem.value = newText;
      if (elem.scrollTop !== scrollTop) {
        elem.scrollTop = scrollTop;
      }
      if (window.document.activeElement === elem) {
        return elem.selectionStart = newSelection[0], elem.selectionEnd = newSelection[1], newSelection;
      }
    };
    insert_listener = function(pos, text) {
      var prevvalue, transformCursor;
      transformCursor = function(cursor) {
        if (pos < cursor) {
          return cursor + text.length;
        } else {
          return cursor;
        }
      };
      prevvalue = elem.value.replace(/\r\n/g, '\n');
      return replaceText(prevvalue.slice(0, pos) + text + prevvalue.slice(pos), transformCursor);
    };
    remove_listener = function(pos, length) {
      var prevvalue, transformCursor;
      transformCursor = function(cursor) {
        if (pos < cursor) {
          return cursor - Math.min(length, cursor - pos);
        } else {
          return cursor;
        }
      };
      prevvalue = elem.value.replace(/\r\n/g, '\n');
      return replaceText(prevvalue.slice(0, pos) + prevvalue.slice(pos + length), transformCursor);
    };
    genOp = function(event) {
      var onNextTick;
      onNextTick = function(fn) {
        return setTimeout(fn, 0);
      };
      return onNextTick(function() {
        var prevvalue;
        if (elem.value !== prevvalue) {
          prevvalue = elem.value;
          return applyChange(doc, doc.getText(), elem.value.replace(/\r\n/g, '\n'));
        }
      });
    };
    attach = function() {
      var event, prevvalue, _i, _len, _ref;
      if (!doc.provides.text) {
        return typeof console !== "undefined" && console !== null ? console.warn('Could not attach document: text api incompatible') : void 0;
      }
      prevvalue = elem.value = doc.getText();
      doc.on('insert', insert_listener);
      doc.on('remove', remove_listener);
      _ref = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        if (elem.addEventListener) {
          elem.addEventListener(event, genOp, false);
        } else {
          elem.attachEvent('on' + event, genOp);
        }
      }
      return doc.once('deleted', detach);
    };
    detach = elem.detach_share = function() {
      var event, _i, _len, _ref;
      doc.removeListener('insert', insert_listener);
      doc.removeListener('remove', remove_listener);
      _ref = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        if (elem.removeEventListener) {
          elem.removeEventListener(event, genOp, false);
        } else {
          elem.detachEvent('on' + event, genOp);
        }
      }
      elem.disabled = true;
      return doc.once('ready', attach);
    };
    if (doc.type) {
      return attach();
    } else {
      return doc.once('ready', attach);
    }
  });

}).call(this);
(function(){var e,r,t,n,o,s,i={exports:{}},a=i.exports;a.name="text",a.uri="http://sharejs.org/types/textv1",a.create=function(e){if(null!=e&&"string"!=typeof e)throw Error("Initial data must be a string");return e||""},e=function(e){var r,t,n,o;if(!Array.isArray(e))throw Error("Op must be an array of components");for(t=null,n=0,o=e.length;o>n;n++){switch(r=e[n],typeof r){case"object":if(!("number"==typeof r.d&&r.d>0))throw Error("Object components must be deletes of size > 0");break;case"string":if(!(r.length>0))throw Error("Inserts cannot be empty");break;case"number":if(!(r>0))throw Error("Skip components must be >0");if("number"==typeof t)throw Error("Adjacent skip components should be combined")}t=r}if("number"==typeof t)throw Error("Op has a trailing skip")},t=function(e){return function(r){return r&&0!==r.d?0===e.length?e.push(r):typeof r==typeof e[e.length-1]?"object"==typeof r?e[e.length-1].d+=r.d:e[e.length-1]+=r:e.push(r):void 0}},n=function(e){var r,t,n,o;return r=0,t=0,o=function(n,o){var s,i;return r===e.length?-1===n?null:n:(s=e[r],"number"==typeof s?-1===n||n>=s-t?(i=s-t,++r,t=0,i):(t+=n,n):"string"==typeof s?-1===n||"i"===o||n>=s.length-t?(i=s.slice(t),++r,t=0,i):(i=s.slice(t,t+n),t+=n,i):-1===n||"d"===o||n>=s.d-t?(i={d:s.d-t},++r,t=0,i):(t+=n,{d:n}))},n=function(){return e[r]},[o,n]},r=function(e){return"number"==typeof e?e:e.length||e.d},s=function(e){return e.length>0&&"number"==typeof e[e.length-1]&&e.pop(),e},a.normalize=function(e){var r,n,o,i,a;for(o=[],r=t(o),i=0,a=e.length;a>i;i++)n=e[i],r(n);return s(o)},a.apply=function(r,t){var n,o,s,i,a;if("string"!=typeof r)throw Error("Snapshot should be a string");for(e(t),s=0,o=[],i=0,a=t.length;a>i;i++)switch(n=t[i],typeof n){case"number":if(n>r.length)throw Error("The op is too long for this document");o.push(r.slice(0,n)),r=r.slice(n);break;case"string":o.push(n);break;case"object":r=r.slice(n.d)}return o.join("")+r},a.transform=function(o,i,a){var c,f,u,h,p,b,l,g,m,y,d;if("left"!==a&&"right"!==a)throw Error("side ("+a+") must be 'left' or 'right'");for(e(o),e(i),p=[],c=t(p),d=n(o),g=d[0],l=d[1],m=0,y=i.length;y>m;m++)switch(u=i[m],typeof u){case"number":for(h=u;h>0;)f=g(h,"i"),c(f),"string"!=typeof f&&(h-=r(f));break;case"string":"left"===a&&(b=l(),"string"==typeof b&&c(g(-1))),c(u.length);break;case"object":for(h=u.d;h>0;)switch(f=g(h,"i"),typeof f){case"number":h-=f;break;case"string":c(f);break;case"object":h-=f.d}}for(;u=g(-1);)c(u);return s(p)},a.compose=function(o,i){var a,c,f,u,h,p,b,l,g,m;for(e(o),e(i),h=[],a=t(h),m=n(o),p=m[0],b=m[1],l=0,g=i.length;g>l;l++)switch(f=i[l],typeof f){case"number":for(u=f;u>0;)c=p(u,"d"),a(c),"object"!=typeof c&&(u-=r(c));break;case"string":a(f);break;case"object":for(u=f.d;u>0;)switch(c=p(u,"d"),typeof c){case"number":a({d:c}),u-=c;break;case"string":u-=c.length;break;case"object":a(c)}}for(;f=p(-1);)a(f);return s(h)},o=function(e,r){var t,n,o,s;for(n=0,o=0,s=r.length;s>o&&(t=r[o],!(n>=e));o++)switch(typeof t){case"number":if(n+t>=e)return e;n+=t;break;case"string":n+=t.length,e+=t.length;break;case"object":e-=Math.min(t.d,e-n)}return e},a.transformCursor=function(e,r,t){var n,s,i,a;if(s=0,t){for(i=0,a=r.length;a>i;i++)switch(n=r[i],typeof n){case"number":s+=n;break;case"string":s+=n.length}return[s,s]}return[o(e[0],r),o(e[1],r)]};var c=window.ottypes=window.ottypes||{},f=i.exports;c[f.name]=f,f.uri&&(c[f.uri]=f)})();(function(){var e={exports:{}},n=e.exports;n._bootstrapTransform=function(e,n,i,t){var r,o;return r=function(e,i,t,r){return n(t,e,i,"left"),n(r,i,e,"right")},e.transformX=e.transformX=o=function(e,n){var l,p,d,f,s,u,c,a,h,v,g,m,w,y,O,b,k,E,x;for(i(e),i(n),s=[],v=0,y=n.length;y>v;v++){for(h=n[v],f=[],l=0;e.length>l;){if(u=[],r(e[l],h,f,u),l++,1!==u.length){if(0===u.length){for(E=e.slice(l),g=0,O=E.length;O>g;g++)p=E[g],t(f,p);h=null;break}for(x=o(e.slice(l),u),d=x[0],a=x[1],m=0,b=d.length;b>m;m++)p=d[m],t(f,p);for(w=0,k=a.length;k>w;w++)c=a[w],t(s,c);h=null;break}h=u[0]}null!=h&&t(s,h),e=f}return[e,s]},e.transform=e.transform=function(e,i,t){if("left"!==t&&"right"!==t)throw Error("type must be 'left' or 'right'");return 0===i.length?e:1===e.length&&1===i.length?n([],e[0],i[0],t):"left"===t?o(e,i)[0]:o(i,e)[1]}};var i,t,r,o,l,p,d,f;p={name:"text-old",uri:"http://sharejs.org/types/textv0",create:function(){return""}},l=function(e,n,i){return e.slice(0,n)+i+e.slice(n)},t=function(e){var n,i;if("number"!=typeof e.p)throw Error("component missing position field");if(i=typeof e.i,n=typeof e.d,!("string"===i^"string"===n))throw Error("component needs an i or d field");if(!(e.p>=0))throw Error("position cannot be negative")},r=function(e){var n,i,r;for(i=0,r=e.length;r>i;i++)n=e[i],t(n);return!0},p.apply=function(e,n){var i,t,o,p;for(r(n),o=0,p=n.length;p>o;o++)if(i=n[o],null!=i.i)e=l(e,i.p,i.i);else{if(t=e.slice(i.p,i.p+i.d.length),i.d!==t)throw Error("Delete component '"+i.d+"' does not match deleted text '"+t+"'");e=e.slice(0,i.p)+e.slice(i.p+i.d.length)}return e},p._append=i=function(e,n){var i,t,r;if(""!==n.i&&""!==n.d)return 0===e.length?e.push(n):(i=e[e.length-1],null!=i.i&&null!=n.i&&i.p<=(t=n.p)&&i.p+i.i.length>=t?e[e.length-1]={i:l(i.i,n.p-i.p,n.i),p:i.p}:null!=i.d&&null!=n.d&&n.p<=(r=i.p)&&n.p+n.d.length>=r?e[e.length-1]={d:l(n.d,i.p-n.p,i.d),p:n.p}:e.push(n))},p.compose=function(e,n){var t,o,l,p;for(r(e),r(n),o=e.slice(),l=0,p=n.length;p>l;l++)t=n[l],i(o,t);return o},p.compress=function(e){return p.compose([],e)},p.normalize=function(e){var n,t,r,o,l;for(t=[],(null!=e.i||null!=e.p)&&(e=[e]),r=0,o=e.length;o>r;r++)n=e[r],null==(l=n.p)&&(n.p=0),i(t,n);return t},f=function(e,n,i){return null!=n.i?e>n.p||n.p===e&&i?e+n.i.length:e:n.p>=e?e:n.p+n.d.length>=e?n.p:e-n.d.length},p.transformCursor=function(e,n,i){var t,r,o,l;for(r="right"===i,o=0,l=n.length;l>o;o++)t=n[o],e=f(e,t,r);return e},p._tc=d=function(e,n,t,o){var l,p,d,s,u,c;if(r([n]),r([t]),null!=n.i)i(e,{i:n.i,p:f(n.p,t,"right"===o)});else if(null!=t.i)c=n.d,n.p<t.p&&(i(e,{d:c.slice(0,t.p-n.p),p:n.p}),c=c.slice(t.p-n.p)),""!==c&&i(e,{d:c,p:n.p+t.i.length});else if(n.p>=t.p+t.d.length)i(e,{d:n.d,p:n.p-t.d.length});else if(n.p+n.d.length<=t.p)i(e,n);else{if(s={d:"",p:n.p},n.p<t.p&&(s.d=n.d.slice(0,t.p-n.p)),n.p+n.d.length>t.p+t.d.length&&(s.d+=n.d.slice(t.p+t.d.length-n.p)),d=Math.max(n.p,t.p),p=Math.min(n.p+n.d.length,t.p+t.d.length),l=n.d.slice(d-n.p,p-n.p),u=t.d.slice(d-t.p,p-t.p),l!==u)throw Error("Delete ops delete different text in the same region of the document");""!==s.d&&(s.p=f(s.p,t),i(e,s))}return e},o=function(e){return null!=e.i?{d:e.i,p:e.p}:{i:e.d,p:e.p}},p.invert=function(e){var n,i,t,r,l;for(r=e.slice().reverse(),l=[],i=0,t=r.length;t>i;i++)n=r[i],l.push(o(n));return l},"undefined"!=typeof window&&null!==window?n._bootstrapTransform(p,p.transformComponent,p.checkValidOp,p.append):require("./helpers")._bootstrapTransform(p,p.transformComponent,p.checkValidOp,p.append),e.exports=p;var s,u,c,p;p="undefined"!=typeof window&&null!==window?e.exports:require("./text-old"),c={name:"json0",uri:"http://sharejs.org/types/JSONv0"},c.create=function(){return null},c.invertComponent=function(e){var n;return n={p:e.p},void 0!==e.si&&(n.sd=e.si),void 0!==e.sd&&(n.si=e.sd),void 0!==e.oi&&(n.od=e.oi),void 0!==e.od&&(n.oi=e.od),void 0!==e.li&&(n.ld=e.li),void 0!==e.ld&&(n.li=e.ld),void 0!==e.na&&(n.na=-e.na),void 0!==e.lm&&(n.lm=e.p[e.p.length-1],n.p=e.p.slice(0,e.p.length-1).concat([e.lm])),n},c.invert=function(e){var n,i,t,r,o;for(r=e.slice().reverse(),o=[],i=0,t=r.length;t>i;i++)n=r[i],o.push(c.invertComponent(n));return o},c.checkValidOp=function(){},u=function(e){return"[object Array]"===Object.prototype.toString.call(e)},c.checkList=function(e){if(!u(e))throw Error("Referenced element not a list")},c.checkObj=function(e){if(e.constructor!==Object)throw Error("Referenced element not an object (it was "+JSON.stringify(e)+")")},c.apply=function(e,n){var i,t,r,o,l,p,d,f,u,a,h,v,g,m;for(c.checkValidOp(n),n=s(n),t={data:e},l=a=0,v=n.length;v>a;l=++a){for(i=n[l],f=null,u=null,o=t,p="data",m=i.p,h=0,g=m.length;g>h;h++)if(d=m[h],f=o,u=p,o=o[p],p=d,null==f)throw Error("Path invalid");if(void 0!==i.na){if("number"!=typeof o[p])throw Error("Referenced element not a number");o[p]+=i.na}else if(void 0!==i.si){if("string"!=typeof o)throw Error("Referenced element not a string (it was "+JSON.stringify(o)+")");f[u]=o.slice(0,p)+i.si+o.slice(p)}else if(void 0!==i.sd){if("string"!=typeof o)throw Error("Referenced element not a string");if(o.slice(p,p+i.sd.length)!==i.sd)throw Error("Deleted string does not match");f[u]=o.slice(0,p)+o.slice(p+i.sd.length)}else if(void 0!==i.li&&void 0!==i.ld)c.checkList(o),o[p]=i.li;else if(void 0!==i.li)c.checkList(o),o.splice(p,0,i.li);else if(void 0!==i.ld)c.checkList(o),o.splice(p,1);else if(void 0!==i.lm)c.checkList(o),i.lm!==p&&(r=o[p],o.splice(p,1),o.splice(i.lm,0,r));else if(void 0!==i.oi)c.checkObj(o),o[p]=i.oi;else{if(void 0===i.od)throw Error("invalid / missing instruction in op");c.checkObj(o),delete o[p]}}return t.data},c.pathMatches=function(e,n,i){var t,r,o,l;if(e.length!==n.length)return!1;for(t=o=0,l=e.length;l>o;t=++o)if(r=e[t],r!==n[t]&&(!i||t!==e.length-1))return!1;return!0},c.append=function(e,n){var i;return n=s(n),0!==e.length&&c.pathMatches(n.p,(i=e[e.length-1]).p)?void 0!==i.na&&void 0!==n.na?e[e.length-1]={p:i.p,na:i.na+n.na}:void 0!==i.li&&void 0===n.li&&n.ld===i.li?void 0!==i.ld?delete i.li:e.pop():void 0!==i.od&&void 0===i.oi&&void 0!==n.oi&&void 0===n.od?i.oi=n.oi:void 0!==n.lm&&n.p[n.p.length-1]===n.lm?null:e.push(n):e.push(n)},c.compose=function(e,n){var i,t,r,o;for(c.checkValidOp(e),c.checkValidOp(n),t=s(e),r=0,o=n.length;o>r;r++)i=n[r],c.append(t,i);return t},c.normalize=function(e){var n,i,t,r,o;for(i=[],u(e)||(e=[e]),t=0,r=e.length;r>t;t++)n=e[t],null==(o=n.p)&&(n.p=[]),c.append(i,n);return i},s=function(e){return JSON.parse(JSON.stringify(e))},c.canOpAffectOp=function(e,n){var i,t,r,o;if(0===e.length)return!0;if(0===n.length)return!1;for(n=n.slice(0,n.length-1),e=e.slice(0,e.length-1),i=r=0,o=e.length;o>r;i=++r){if(t=e[i],i>=n.length)return!1;if(t!==n[i])return!1}return!0},c.transformComponent=function(e,n,i,t){var r,o,l,d,f,u,a,h,v,g,m,w,y,O,b,k,E,x,j;if(n=s(n),void 0!==n.na&&n.p.push(0),void 0!==i.na&&i.p.push(0),c.canOpAffectOp(i.p,n.p)&&(r=i.p.length-1),c.canOpAffectOp(n.p,i.p)&&(o=n.p.length-1),f=n.p.length,v=i.p.length,void 0!==n.na&&n.p.pop(),void 0!==i.na&&i.p.pop(),i.na)return null!=o&&v>=f&&i.p[o]===n.p[o]&&(void 0!==n.ld?(h=s(i),h.p=h.p.slice(f),n.ld=c.apply(s(n.ld),[h])):void 0!==n.od&&(h=s(i),h.p=h.p.slice(f),n.od=c.apply(s(n.od),[h]))),c.append(e,n),e;if(null!=o&&v>f&&n.p[o]===i.p[o]&&(void 0!==n.ld?(h=s(i),h.p=h.p.slice(f),n.ld=c.apply(s(n.ld),[h])):void 0!==n.od&&(h=s(i),h.p=h.p.slice(f),n.od=c.apply(s(n.od),[h]))),null!=r)if(l=f===v,void 0!==i.na);else if(void 0!==i.si||void 0!==i.sd){if(void 0!==n.si||void 0!==n.sd){if(!l)throw Error("must be a string?");for(d=function(e){var n;return n={p:e.p[e.p.length-1]},null!=e.si?n.i=e.si:n.d=e.sd,n},b=d(n),k=d(i),y=[],p._tc(y,b,k,t),x=0,j=y.length;j>x;x++)O=y[x],a={p:n.p.slice(0,r)},a.p.push(O.p),null!=O.i&&(a.si=O.i),null!=O.d&&(a.sd=O.d),c.append(e,a);return e}}else if(void 0!==i.li&&void 0!==i.ld){if(i.p[r]===n.p[r]){if(!l)return e;if(void 0!==n.ld){if(void 0===n.li||"left"!==t)return e;n.ld=s(i.li)}}}else if(void 0!==i.li)void 0!==n.li&&void 0===n.ld&&l&&n.p[r]===i.p[r]?"right"===t&&n.p[r]++:i.p[r]<=n.p[r]&&n.p[r]++,void 0!==n.lm&&l&&i.p[r]<=n.lm&&n.lm++;else if(void 0!==i.ld){if(void 0!==n.lm&&l){if(i.p[r]===n.p[r])return e;w=i.p[r],u=n.p[r],E=n.lm,(E>w||w===E&&E>u)&&n.lm--}if(i.p[r]<n.p[r])n.p[r]--;else if(i.p[r]===n.p[r]){if(f>v)return e;if(void 0!==n.ld){if(void 0===n.li)return e;delete n.ld}}}else if(void 0!==i.lm)if(void 0!==n.lm&&f===v){if(u=n.p[r],E=n.lm,g=i.p[r],m=i.lm,g!==m)if(u===g){if("left"!==t)return e;n.p[r]=m,u===E&&(n.lm=m)}else u>g&&n.p[r]--,u>m?n.p[r]++:u===m&&g>m&&(n.p[r]++,u===E&&n.lm++),E>g?n.lm--:E===g&&E>u&&n.lm--,E>m?n.lm++:E===m&&(m>g&&E>u||g>m&&u>E?"right"===t&&n.lm++:E>u?n.lm++:E===g&&n.lm--)}else void 0!==n.li&&void 0===n.ld&&l?(u=i.p[r],E=i.lm,w=n.p[r],w>u&&n.p[r]--,w>E&&n.p[r]++):(u=i.p[r],E=i.lm,w=n.p[r],w===u?n.p[r]=E:(w>u&&n.p[r]--,w>E?n.p[r]++:w===E&&u>E&&n.p[r]++));else if(void 0!==i.oi&&void 0!==i.od){if(n.p[r]===i.p[r]){if(void 0===n.oi||!l)return e;if("right"===t)return e;n.od=i.oi}}else if(void 0!==i.oi){if(void 0!==n.oi&&n.p[r]===i.p[r]){if("left"!==t)return e;c.append(e,{p:n.p,od:i.oi})}}else if(void 0!==i.od&&n.p[r]===i.p[r]){if(!l)return e;if(void 0===n.oi)return e;delete n.od}return c.append(e,n),e},"undefined"!=typeof window&&null!==window?n._bootstrapTransform(c,c.transformComponent,c.checkValidOp,c.append):require("./helpers")._bootstrapTransform(c,c.transformComponent,c.checkValidOp,c.append),e.exports=c;var a=window.ottypes=window.ottypes||{},h=e.exports;a[h.name]=h,h.uri&&(a[h.uri]=h)})();