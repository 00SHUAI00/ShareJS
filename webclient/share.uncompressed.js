(function(){
(function(){var e,r,t,n,o,s,i={exports:{}},a=i.exports;a.name="text",a.uri="http://sharejs.org/types/textv1",a.create=function(e){if(null!=e&&"string"!=typeof e)throw Error("Initial data must be a string");return e||""},e=function(e){var r,t,n,o;if(!Array.isArray(e))throw Error("Op must be an array of components");for(t=null,n=0,o=e.length;o>n;n++){switch(r=e[n],typeof r){case"object":if(!("number"==typeof r.d&&r.d>0))throw Error("Object components must be deletes of size > 0");break;case"string":if(!(r.length>0))throw Error("Inserts cannot be empty");break;case"number":if(!(r>0))throw Error("Skip components must be >0");if("number"==typeof t)throw Error("Adjacent skip components should be combined")}t=r}if("number"==typeof t)throw Error("Op has a trailing skip")},t=function(e){return function(r){return r&&0!==r.d?0===e.length?e.push(r):typeof r==typeof e[e.length-1]?"object"==typeof r?e[e.length-1].d+=r.d:e[e.length-1]+=r:e.push(r):void 0}},n=function(e){var r,t,n,o;return r=0,t=0,o=function(n,o){var s,i;return r===e.length?-1===n?null:n:(s=e[r],"number"==typeof s?-1===n||n>=s-t?(i=s-t,++r,t=0,i):(t+=n,n):"string"==typeof s?-1===n||"i"===o||n>=s.length-t?(i=s.slice(t),++r,t=0,i):(i=s.slice(t,t+n),t+=n,i):-1===n||"d"===o||n>=s.d-t?(i={d:s.d-t},++r,t=0,i):(t+=n,{d:n}))},n=function(){return e[r]},[o,n]},r=function(e){return"number"==typeof e?e:e.length||e.d},s=function(e){return e.length>0&&"number"==typeof e[e.length-1]&&e.pop(),e},a.normalize=function(e){var r,n,o,i,a;for(o=[],r=t(o),i=0,a=e.length;a>i;i++)n=e[i],r(n);return s(o)},a.apply=function(r,t){var n,o,s,i,a;if("string"!=typeof r)throw Error("Snapshot should be a string");for(e(t),s=0,o=[],i=0,a=t.length;a>i;i++)switch(n=t[i],typeof n){case"number":if(n>r.length)throw Error("The op is too long for this document");o.push(r.slice(0,n)),r=r.slice(n);break;case"string":o.push(n);break;case"object":r=r.slice(n.d)}return o.join("")+r},a.transform=function(o,i,a){var c,f,u,h,p,b,l,g,m,y,d;if("left"!==a&&"right"!==a)throw Error("side ("+a+") must be 'left' or 'right'");for(e(o),e(i),p=[],c=t(p),d=n(o),g=d[0],l=d[1],m=0,y=i.length;y>m;m++)switch(u=i[m],typeof u){case"number":for(h=u;h>0;)f=g(h,"i"),c(f),"string"!=typeof f&&(h-=r(f));break;case"string":"left"===a&&(b=l(),"string"==typeof b&&c(g(-1))),c(u.length);break;case"object":for(h=u.d;h>0;)switch(f=g(h,"i"),typeof f){case"number":h-=f;break;case"string":c(f);break;case"object":h-=f.d}}for(;u=g(-1);)c(u);return s(p)},a.compose=function(o,i){var a,c,f,u,h,p,b,l,g,m;for(e(o),e(i),h=[],a=t(h),m=n(o),p=m[0],b=m[1],l=0,g=i.length;g>l;l++)switch(f=i[l],typeof f){case"number":for(u=f;u>0;)c=p(u,"d"),a(c),"object"!=typeof c&&(u-=r(c));break;case"string":a(f);break;case"object":for(u=f.d;u>0;)switch(c=p(u,"d"),typeof c){case"number":a({d:c}),u-=c;break;case"string":u-=c.length;break;case"object":a(c)}}for(;f=p(-1);)a(f);return s(h)},o=function(e,r){var t,n,o,s;for(n=0,o=0,s=r.length;s>o&&(t=r[o],!(n>=e));o++)switch(typeof t){case"number":if(n+t>=e)return e;n+=t;break;case"string":n+=t.length,e+=t.length;break;case"object":e-=Math.min(t.d,e-n)}return e},a.transformCursor=function(e,r,t){var n,s,i,a;if(s=0,t){for(i=0,a=r.length;a>i;i++)switch(n=r[i],typeof n){case"number":s+=n;break;case"string":s+=n.length}return[s,s]}return[o(e[0],r),o(e[1],r)]};var c=window.ottypes=window.ottypes||{},f=i.exports;c[f.name]=f,f.uri&&(c[f.uri]=f)})();// Generated by CoffeeScript 1.6.1
var exports;

window.sharejs = exports = {
  version: '0.7.0'
};

if (typeof WEB === 'undefined') {
  window.WEB = true;
}
// Generated by CoffeeScript 1.6.1
var MicroEvent, nextTick,
  __slice = [].slice;

nextTick = typeof WEB !== "undefined" && WEB !== null ? function(fn) {
  return setTimeout(fn, 0);
} : process['nextTick'];

MicroEvent = (function() {

  function MicroEvent() {}

  MicroEvent.prototype.on = function(event, fn) {
    var _base;
    this._events || (this._events = {});
    (_base = this._events)[event] || (_base[event] = []);
    this._events[event].push(fn);
    return this;
  };

  MicroEvent.prototype.removeListener = function(event, fn) {
    var i, listeners, _base,
      _this = this;
    this._events || (this._events = {});
    listeners = ((_base = this._events)[event] || (_base[event] = []));
    i = 0;
    while (i < listeners.length) {
      if (listeners[i] === fn) {
        listeners[i] = void 0;
      }
      i++;
    }
    nextTick(function() {
      var x;
      return _this._events[event] = (function() {
        var _i, _len, _ref, _results;
        _ref = this._events[event];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          if (x) {
            _results.push(x);
          }
        }
        return _results;
      }).call(_this);
    });
    return this;
  };

  MicroEvent.prototype.emit = function() {
    var args, event, fn, _i, _len, _ref, _ref1;
    event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!((_ref = this._events) != null ? _ref[event] : void 0)) {
      if (event === 'error') {
        if (typeof console !== "undefined" && console !== null) {
          console.error.apply(console, args);
        }
      }
      return this;
    }
    _ref1 = this._events[event];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      fn = _ref1[_i];
      if (fn) {
        fn.apply(this, args);
      }
    }
    return this;
  };

  MicroEvent.prototype.once = function(event, fn) {
    var listener,
      _this = this;
    return this.on(event, listener = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.removeListener(event, listener);
      return fn.apply(_this, args);
    });
  };

  return MicroEvent;

})();

MicroEvent.mixin = function(obj) {
  var proto;
  proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof WEB === "undefined" || WEB === null) {
  module.exports = MicroEvent;
}
// Generated by CoffeeScript 1.6.1
var Doc, MicroEvent, types;

if (typeof WEB === "undefined" || WEB === null) {
  types = require('ot-types');
}

if (typeof WEB !== "undefined" && WEB !== null) {
  exports.extendDoc = function(name, fn) {
    return Doc.prototype[name] = fn;
  };
}

Doc = (function() {
  var setNoOp;

  function Doc(connection, collection, name, data) {
    this.connection = connection;
    this.collection = collection;
    this.name = name;
    this.subscribed = false;
    this.subscribeRequested = false;
    this.inflightData = null;
    this.pendingData = [];
    if (data) {
      this._injestData(data);
    }
  }

  Doc.prototype._send = function(message) {
    message.c = this.collection;
    message.doc = this.name;
    return this.connection.send(message);
  };

  Doc.prototype.subscribe = function(callback) {
    var msg,
      _this = this;
    if (this.subscribeRequested) {
      return;
    }
    this.subscribeRequested = true;
    if (callback) {
      this._subscribeCallback = function(error) {
        _this._subscribeCallback = null;
        return callback(error);
      };
    }
    if (this.connection.state === 'disconnected') {
      return;
    }
    msg = {
      a: 'sub'
    };
    if (typeof this.version === 'number') {
      msg.v = this.version;
    }
    return this._send(msg);
  };

  Doc.prototype.unsubscribe = function(callback) {
    var _this = this;
    if (!this.subscribeRequested) {
      return;
    }
    this.subscribeRequested = false;
    if (this.connection.state === 'disconnected') {
      return;
    }
    if (callback) {
      this._unsubscribeCallback = function(error) {
        _this._unsubscribeCallback = null;
        return callback(error);
      };
    }
    return this._send({
      a: 'unsub'
    });
  };

  Doc.prototype.fetch = function(callback) {
    if (callback) {
      this.once('fetched', callback);
    }
    return this._send({
      a: 'fetch'
    });
  };

  Doc.prototype._connectionStateChanged = function(state, data) {
    switch (state) {
      case 'disconnected':
        this.subscribed = false;
        break;
      case 'connecting':
        if (this.subscribeRequested) {
          this.subscribeRequested = false;
          this.subscribe();
        }
        if (this.inflightData) {
          this._sendOpData(this.inflightData);
        }
    }
    return this.emit(state, data);
  };

  Doc.prototype._setType = function(type) {
    var k, v, _ref, _ref1;
    if (typeof type === 'string') {
      if (!types[type]) {
        throw new Error("Missing type " + type);
      }
      type = types[type];
    }
    if (type && !type.compose) {
      throw new Error('Support for types without compose() is not implemented');
    }
    if ((_ref = this.type) != null ? _ref.api : void 0) {
      if (this._onOp) {
        this.removeListener('op', this._onOp);
      }
      for (k in this.type.api) {
        delete this[k];
      }
    }
    this.type = type;
    if (!this.type) {
      this.snapshot = null;
    }
    if (type != null ? type.api : void 0) {
      _ref1 = type.api;
      for (k in _ref1) {
        v = _ref1[k];
        this[k] = v;
      }
      if (this._onOp) {
        return this.on('op', this._onOp);
      }
    } else {
      return this.provides = {};
    }
  };

  Doc.prototype._injestData = function(data) {
    if (typeof data.v !== 'number') {
      throw new Error('Missing version');
    }
    if (typeof this.version === 'number') {
      if (typeof console !== "undefined" && console !== null) {
        console.warn('Ignoring extra attempt to injest data');
      }
      return;
    }
    this.version = data.v;
    this.snapshot = data.snapshot;
    return this._setType(data.type);
  };

  setNoOp = function(data) {
    delete data.op;
    delete data.create;
    return delete data.del;
  };

  Doc.prototype._xf = function(client, server) {
    var _ref;
    if (server.create || server.del) {
      return setNoOp(client);
    }
    if (client.del) {
      return setNoOp(server);
    }
    if (client.create) {
      throw new Error('Invalid state. This is a bug. Please file an issue on github');
    }
    if (!(server.op && client.op)) {
      return;
    }
    if (client.type.transformX) {
      return _ref = client.type.transformX(client.op, server.op), client.op = _ref[0], server.op = _ref[1], _ref;
    } else {
      client.op = this.type.transform(client.op, server.op, 'left');
      return server.op = this.type.transform(server.op, client.op, 'right');
    }
  };

  Doc.prototype._otApply = function(opData, isLocal) {
    var create, op,
      _this = this;
    this.locked = true;
    if ((create = opData.create)) {
      this._setType(create.type);
      this.snapshot = this.type.create(create.data);
      setTimeout((function() {
        return _this.emit('ready', isLocal);
      }), 0);
      return setTimeout((function() {
        return _this.emit('created', isLocal);
      }), 0);
    } else if (opData.del) {
      this._setType(null);
      return setTimeout((function() {
        return _this.emit('deleted', isLocal);
      }), 0);
    } else if ((op = opData.op)) {
      if (!this.type) {
        throw new Error('Document does not exist');
      }
      op = opData.op;
      this.emit('before op', op, isLocal);
      if (this.incremental && this.type.incrementalApply) {
        return this.type.incrementalApply(this.snapshot, op, function(o, snapshot) {
          _this.snapshot = snapshot;
          return _this.emit('op', o, isLocal);
        });
      } else {
        this.snapshot = this.type.apply(this.snapshot, op);
        return this.emit('op', op, isLocal);
      }
    } else {
      return typeof console !== "undefined" && console !== null ? console.warn('Ignoring received no-op.', opData) : void 0;
    }
  };

  Doc.prototype._afterOtApply = function(opData, isLocal) {
    this.locked = false;
    if (opData.op) {
      return this.emit('after op', opData.op, isLocal);
    }
  };

  Doc.prototype._tryRollback = function(opData) {
    var p, undo, _i, _len, _ref;
    if (opData.create) {
      return this._setType(null);
    } else if (opData.op && opData.type.invert) {
      undo = opData.type.invert(opData.op);
      _ref = this.pendingData;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        this._xf(p, undo);
      }
      this._otApply(undo, false);
      return this._afterOtApply(undo, false);
    } else {
      this.emit('error', "Op apply failed and the operation could not be reverted");
      this._setType(null);
      this.v = null;
      return this.fetch();
    }
  };

  Doc.prototype._opAcknowledged = function(msg) {
    var acknowledgedData, callback, error, _i, _len, _ref;
    if (error === 'Op already submitted') {
      return;
    }
    acknowledgedData = this.inflightData;
    this.inflightData = null;
    error = msg.error;
    if (error) {
      this._tryRollback(acknowledgedData);
    } else {
      if (msg.v !== this.version) {
        throw new Error('Invalid version from server. Please file an issue, this is a bug.');
      }
      this.version++;
      this.emit('acknowledge', acknowledgedData);
    }
    _ref = acknowledgedData.callbacks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      callback = _ref[_i];
      callback(error);
    }
    return this.flush();
  };

  Doc.prototype._onMessage = function(msg) {
    var opData, path, pending, value, _i, _len, _ref, _ref1;
    if (!(msg.c === this.collection && msg.doc === this.name)) {
      throw new Error("Got message for wrong document. Expected '" + this.collection + "'.'" + this.name + "' but got '" + msg.c + "'.'" + msg.doc + "'");
    }
    switch (msg.a) {
      case 'data':
        this._injestData(msg);
        if (this.type) {
          this.emit('ready');
        }
        return this.emit('fetched');
      case 'sub':
        if (msg.error) {
          if (typeof console !== "undefined" && console !== null) {
            console.error("Could not open document: " + msg.error);
          }
          this.emit('error', msg.error);
          this.subscribed = false;
          this.subscribeRequested = false;
          if (typeof this._subscribeCallback === "function") {
            this._subscribeCallback(msg.error);
          }
          break;
        }
        this.subscribed = true;
        this.emit('subscribed');
        if (typeof this._subscribeCallback === "function") {
          this._subscribeCallback();
        }
        return this.flush();
      case 'unsub':
        this.subscribed = false;
        this.emit('unsubscribed');
        return typeof this._unsubscribeCallback === "function" ? this._unsubscribeCallback() : void 0;
      case 'ack':
        if (msg.error) {
          return this._opAcknowledged(msg);
        }
        break;
      case 'op':
        if (this.inflightData && msg.src === this.inflightData.src && msg.seq === this.inflightData.seq) {
          this._opAcknowledged(msg);
          break;
        }
        if (msg.v !== this.version) {
          return this.emit('error', "Expected version " + this.version + " but got " + msg.v);
        }
        opData = msg;
        if (this.inflightData) {
          this._xf(this.inflightData, opData);
        }
        _ref = this.pendingData;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pending = _ref[_i];
          this._xf(pending, opData);
        }
        this.version++;
        this._otApply(opData, false);
        return this._afterOtApply(opData, false);
      case 'meta':
        _ref1 = msg.meta, path = _ref1.path, value = _ref1.value;
        return typeof console !== "undefined" && console !== null ? console.warn('Unhandled meta op:', msg) : void 0;
      default:
        return typeof console !== "undefined" && console !== null ? console.warn('Unhandled document message:', msg) : void 0;
    }
  };

  Doc.prototype._submitOpData = function(opData, callback) {
    var entry, error,
      _this = this;
    error = function(err) {
      if (callback) {
        return callback(err);
      } else {
        return typeof console !== "undefined" && console !== null ? console.warn('Failed attempt to submitOp:', err) : void 0;
      }
    };
    if (!this.subscribeRequested) {
      return error('You cannot currently submit operations to an unsubscribed document');
    }
    if (this.locked) {
      return error("Cannot call submitOp from inside an 'op' event handler");
    }
    if (opData.op) {
      if (!this.type) {
        error('Document has not been created');
      }
      if (this.type.normalize != null) {
        opData.op = this.type.normalize(opData.op);
      }
    }
    this._otApply(opData, true);
    if (opData.op && this.pendingData.length && (entry = this.pendingData[this.pendingData.length - 1]).op) {
      entry.op = this.type.compose(entry.op, opData.op);
    } else {
      entry = opData;
      opData.type = this.type;
      opData.callbacks = [];
      this.pendingData.push(opData);
    }
    if (callback) {
      entry.callbacks.push(callback);
    }
    this._afterOtApply(opData, true);
    return setTimeout((function() {
      return _this.flush();
    }), 0);
  };

  Doc.prototype.submitOp = function(op, callback) {
    return this._submitOpData({
      op: op
    }, callback);
  };

  Doc.prototype.create = function(type, data, callback) {
    var _ref;
    if (typeof data === 'function') {
      _ref = [void 0, data], data = _ref[0], callback = _ref[1];
    }
    if (this.type) {
      return typeof callback === "function" ? callback('Document already exists') : void 0;
    }
    return this._submitOpData({
      create: {
        type: type,
        data: data
      }
    }, callback);
  };

  Doc.prototype.del = function(callback) {
    if (!this.type) {
      return typeof callback === "function" ? callback('Document does not exist') : void 0;
    }
    return this._submitOpData({
      del: true
    }, callback);
  };

  Doc.prototype._sendOpData = function(d) {
    var msg;
    msg = {
      a: 'op',
      v: this.version
    };
    if (d.src) {
      msg.src = d.src;
      msg.seq = d.seq;
    }
    if (d.op) {
      msg.op = d.op;
    }
    if (d.create) {
      msg.create = d.create;
    }
    if (d.del) {
      msg.del = d.del;
    }
    this._send(msg);
    if (!d.src) {
      d.src = this.connection.id;
      return d.seq = this.connection.seq++;
    }
  };

  Doc.prototype.flush = function() {
    var _ref;
    if (!(((_ref = this.connection.state) === 'connecting' || _ref === 'connected') && this.inflightData === null && this.pendingData.length)) {
      return;
    }
    this.inflightData = this.pendingData.shift();
    return this._sendOpData(this.inflightData);
  };

  Doc.prototype.getSnapshot = function() {
    return this.snapshot;
  };

  return Doc;

})();

if (typeof WEB === "undefined" || WEB === null) {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Doc);

exports.Doc = Doc;
// Generated by CoffeeScript 1.6.1
var Connection, Doc, MicroEvent, types;

if (typeof WEB !== "undefined" && WEB !== null) {
  types = ottypes;
} else {
  types = require('ot-types');
  Doc = require('./doc').Doc;
}

Connection = (function() {

  Connection.prototype._error = function(e) {
    this.setState('stopped', e);
    return this.disconnect(e);
  };

  function Connection(socket) {
    var _this = this;
    this.socket = socket;
    this.collections = {};
    this.state = 'disconnected';
    this.socket.onmessage = function(msg) {
      var collection, doc, docName;
      console.log('RECV', msg);
      if (msg.id) {
        if (msg.protocol !== 0) {
          throw new Error('Invalid protocol version');
        }
        if (typeof msg.id !== 'string') {
          throw new Error('Invalid client id');
        }
        _this.id = msg.id;
        _this.setState('connected');
        return;
      }
      if (msg.doc !== void 0) {
        collection = _this.lastReceivedCollection = msg.c;
        docName = _this.lastReceivedDoc = msg.doc;
      } else {
        collection = msg.c = _this.lastReceivedCollection;
        docName = msg.doc = _this.lastReceivedDoc;
      }
      if ((doc = _this.get(collection, docName))) {
        return doc._onMessage(msg);
      } else {
        return typeof console !== "undefined" && console !== null ? console.error('Unhandled message', msg) : void 0;
      }
    };
    this.connected = false;
    this.socket.onclose = function(reason) {
      _this.setState('disconnected', reason);
      if (reason === 'Closed' || reason === 'Stopped by server') {
        return _this.setState('stopped', _this.lastError || reason);
      }
    };
    this.socket.onerror = function(e) {
      return _this.emit('error', e);
    };
    this.socket.onopen = function() {
      return _this.setState('connecting');
    };
    this.reset();
  }

  Connection.prototype.reset = function() {
    this.id = this.lastError = this.lastReceivedDoc = this.lastSentDoc = null;
    return this.seq = 1;
  };

  Connection.prototype.setState = function(newState, data) {
    var c, collection, doc, docName, _ref, _results;
    if (this.state === newState) {
      return;
    }
    if ((newState === 'connecting' && this.state !== 'disconnected') || (newState === 'connected' && this.state !== 'connecting')) {
      throw new Error("Cannot transition directly from " + this.state + " to " + newState);
    }
    this.state = newState;
    if (newState === 'disconnected') {
      this.reset();
    }
    this.emit(newState, data);
    _ref = this.collections;
    _results = [];
    for (c in _ref) {
      collection = _ref[c];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (docName in collection) {
          doc = collection[docName];
          _results1.push(doc._connectionStateChanged(newState, data));
        }
        return _results1;
      })());
    }
    return _results;
  };

  Connection.prototype.send = function(data) {
    var collection, docName;
    console.log("SEND:", data);
    if (data.doc) {
      docName = data.doc;
      collection = data.c;
      if (collection === this.lastSentCollection && docName === this.lastSentDoc) {
        delete data.c;
        delete data.doc;
      } else {
        this.lastSentCollection = collection;
        this.lastSentDoc = docName;
      }
    }
    return this.socket.send(data);
  };

  Connection.prototype.disconnect = function() {
    return this.socket.close();
  };

  Connection.prototype.get = function(collection, name) {
    var _ref;
    return (_ref = this.collections[collection]) != null ? _ref[name] : void 0;
  };

  Connection.prototype.getOrCreate = function(collection, name, data) {
    var doc, _base;
    doc = this.get(collection, name);
    if (doc) {
      return doc;
    }
    doc = new Doc(this, collection, name, data);
    collection = ((_base = this.collections)[collection] || (_base[collection] = {}));
    return collection[name] = doc;
  };

  return Connection;

})();

/* 
  open: (collection, docName, options, callback) ->
    doc = @openSync collection, name
    doc.on 'ready', ->
      if doc.type and options.type
        doc.create type, -> callback()
      else
        callback()

  openSync: (collection, docName, options = {}) ->
    # options can have:
    # - type:'text'
    # - snapshot:{...}
    # - v:  (if you have a snapshot you also need a version and a type).
    #
    # - subscribe:true / false. Default true.

    
    options.type = types[options.type] if typeof options.type is 'string'

    if typeof options.v is 'number'
      throw new Error 'Missing snapshot' if options.snapshot is undefined
      throw new Error 'Missing type' if options.type is undefined
    else
      delete options.snapshot

    doc = @_get collection, docName
    if doc
      if options.subscribe isnt false
        doc.subscribe()

      return doc

    else
      return @makeDoc collection, docName, options




  makeDoc: (collection, docName, data, callback) ->
    throw new Error("Doc #{docName} already open") if @_get collection, docName
    doc = new Doc(this, collection, docName, data)
    c = (@collections[collection] ||= {})
    c[docName] = doc

    #doc.open (error) =>
    #  if error
    #    delete c[name]
    #  else
    #    doc.on 'closed', => delete c[name]

    #  callback error, (doc unless error)

  # Open a document that already exists
  # callback(error, doc)
  openExisting: (collection, docName, callback) ->
    return callback 'connection closed' if @state is 'stopped'
    doc = @_get collection, docName
    return @_ensureOpenState(doc, callback) if doc
    doc = @makeDoc collection, docName, {}, callback

  # Open a document. It will be created if it doesn't already exist.
  # Callback is passed a document or an error
  # type is either a type name (eg 'text' or 'simple') or the actual type object.
  # Types must be supported by the server.
  # callback(error, doc)
  open: (collection, docName, type, callback) ->
    return callback 'connection closed' if @state is 'stopped'

    # Wait for the connection to open
    if @state is 'connecting'
      @on 'connected', -> @open(collection, docName, type, callback)
      return

    if typeof type is 'function'
      callback = type
      type = 'text'

    callback ||= ->

    type = types[type] if typeof type is 'string'

    throw new Error "OT code for document type missing" unless type

    throw new Error 'Server-generated random doc names are not currently supported' unless docName?

    if (doc = @_get collection, docName)
      if doc.type is type
        @_ensureOpenState(doc, callback)
      else
        callback 'Type mismatch', doc
      return

    @makeDoc collection, docName, {create:true, type:type.name}, callback

  # Call the callback after the document object is open
  _ensureOpenState: (doc, callback) ->
    switch doc.state
      when 'open' then callback null, doc
      when 'opening' then @on 'open', -> callback null, doc
      when 'closed' then doc.open (error) -> callback error, (doc unless error)
    return
*/


if (typeof WEB === "undefined" || WEB === null) {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Connection);

exports.Connection = Connection;
// Generated by CoffeeScript 1.6.1
var Connection, hasBCSocket;

if (typeof WEB !== "undefined" && WEB !== null) {
  hasBCSocket = window.BCSocket !== void 0;
} else {
  Connection = require('./connection').Connection;
}

exports.open = (function() {
  var connections, getConnection, maybeClose;
  connections = {};
  getConnection = function(origin, authentication) {
    var c, del, location;
    if ((typeof WEB !== "undefined" && WEB !== null) && (origin == null)) {
      location = window.location;
      origin = "" + location.protocol + "//" + location.host + "/channel";
    }
    if (!connections[origin]) {
      c = new Connection(new BCSocket(origin, {
        reconnect: true
      }), authentication);
      del = function() {
        return delete connections[origin];
      };
      c.on('disconnected', del);
      c.on('connect failed', del);
      connections[origin] = c;
    }
    return connections[origin];
  };
  maybeClose = function(c) {
    var doc, name, numDocs, _ref;
    numDocs = 0;
    _ref = c.docs;
    for (name in _ref) {
      doc = _ref[name];
      if (doc.state !== 'closed' || doc.autoOpen) {
        numDocs++;
      }
    }
    if (numDocs === 0) {
      return c.disconnect();
    }
  };
  return function(collection, docName, type, options, callback) {
    var authentication, c, origin;
    if (!hasBCSocket) {
      throw new Error('Cannot find browserchannel. If you want to use a custom channel, create a connection manually.');
    }
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (typeof options === 'string') {
      options = {
        origin: options
      };
    }
    origin = options.origin;
    authentication = options.authentication;
    c = getConnection(origin, authentication);
    c.open(collection, docName, type, function(error, doc) {
      if (error) {
        callback(error);
        return maybeClose(c);
      } else {
        doc.on('closed', function() {
          return maybeClose(c);
        });
        return callback(null, doc);
      }
    });
    c.on('connect failed');
    return c;
  };
})();

if (typeof WEB === "undefined" || WEB === null) {
  exports.Doc = require('./doc').Doc;
  exports.Connection = require('./connection').Connection;
}
// Generated by CoffeeScript 1.6.1
var applyChange;

applyChange = function(doc, oldval, newval) {
  var commonEnd, commonStart;
  if (oldval === newval) {
    return;
  }
  commonStart = 0;
  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
    commonStart++;
  }
  commonEnd = 0;
  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) && commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
    commonEnd++;
  }
  if (oldval.length !== commonStart + commonEnd) {
    doc.remove(commonStart, oldval.length - commonStart - commonEnd);
  }
  if (newval.length !== commonStart + commonEnd) {
    return doc.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
  }
};

window.sharejs.extendDoc('attach_textarea', function(elem) {
  var attach, detach, doc, genOp, insert_listener, remove_listener, replaceText;
  doc = this;
  replaceText = function(newText, transformCursor) {
    var newSelection, scrollTop;
    newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
    scrollTop = elem.scrollTop;
    elem.value = newText;
    if (elem.scrollTop !== scrollTop) {
      elem.scrollTop = scrollTop;
    }
    if (window.document.activeElement === elem) {
      return elem.selectionStart = newSelection[0], elem.selectionEnd = newSelection[1], newSelection;
    }
  };
  insert_listener = function(pos, text) {
    var prevvalue, transformCursor;
    transformCursor = function(cursor) {
      if (pos < cursor) {
        return cursor + text.length;
      } else {
        return cursor;
      }
    };
    prevvalue = elem.value.replace(/\r\n/g, '\n');
    return replaceText(prevvalue.slice(0, pos) + text + prevvalue.slice(pos), transformCursor);
  };
  remove_listener = function(pos, length) {
    var prevvalue, transformCursor;
    transformCursor = function(cursor) {
      if (pos < cursor) {
        return cursor - Math.min(length, cursor - pos);
      } else {
        return cursor;
      }
    };
    prevvalue = elem.value.replace(/\r\n/g, '\n');
    return replaceText(prevvalue.slice(0, pos) + prevvalue.slice(pos + length), transformCursor);
  };
  genOp = function(event) {
    var onNextTick;
    onNextTick = function(fn) {
      return setTimeout(fn, 0);
    };
    return onNextTick(function() {
      var prevvalue;
      if (elem.value !== prevvalue) {
        prevvalue = elem.value;
        return applyChange(doc, doc.getText(), elem.value.replace(/\r\n/g, '\n'));
      }
    });
  };
  attach = function() {
    var event, prevvalue, _i, _len, _ref;
    if (!doc.provides.text) {
      return typeof console !== "undefined" && console !== null ? console.warn('Could not attach document: text api incompatible') : void 0;
    }
    prevvalue = elem.value = doc.getText();
    doc.on('insert', insert_listener);
    doc.on('remove', remove_listener);
    _ref = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      if (elem.addEventListener) {
        elem.addEventListener(event, genOp, false);
      } else {
        elem.attachEvent('on' + event, genOp);
      }
    }
    return doc.once('deleted', detach);
  };
  detach = elem.detach_share = function() {
    var event, _i, _len, _ref;
    doc.removeListener('insert', insert_listener);
    doc.removeListener('remove', remove_listener);
    _ref = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      if (elem.removeEventListener) {
        elem.removeEventListener(event, genOp, false);
      } else {
        elem.detachEvent('on' + event, genOp);
      }
    }
    elem.disabled = true;
    return doc.once('ready', attach);
  };
  if (doc.type) {
    return attach();
  } else {
    return doc.once('ready', attach);
  }
});
// Generated by CoffeeScript 1.6.1
var type;

if (typeof WEB !== "undefined" && WEB !== null) {
  type = ottypes.text;
} else {
  type = require('./text');
}

type.api = {
  provides: {
    text: true
  },
  getLength: function() {
    return this.getSnapshot().length;
  },
  getText: function() {
    return this.getSnapshot();
  },
  insert: function(pos, text, callback) {
    var op;
    op = type.normalize([pos, text]);
    this.submitOp(op, callback);
    return op;
  },
  remove: function(pos, length, callback) {
    var op;
    op = type.normalize([
      pos, {
        d: length
      }
    ]);
    this.submitOp(op, callback);
    return op;
  },
  _onOp: function(op, isLocal) {
    var component, pos, spos, _i, _len, _results;
    if (isLocal) {
      return;
    }
    pos = spos = 0;
    _results = [];
    for (_i = 0, _len = op.length; _i < _len; _i++) {
      component = op[_i];
      switch (typeof component) {
        case 'number':
          pos += component;
          _results.push(spos += component);
          break;
        case 'string':
          this.emit('insert', pos, component);
          _results.push(pos += component.length);
          break;
        case 'object':
          this.emit('remove', pos, component.d);
          _results.push(spos += component.d);
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  }
};
})();
